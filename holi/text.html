<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Particle Animation</title>
    <link rel="stylesheet" href="styles.css">
    <style>
        * {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

#canvas1 {
    background: black;
    position: absolute;
    top: 0;
    left: 0;
    opacity: 1;
    width: 100vw; /* Full width of the viewport */
    height: 100vh; /* Full height of the viewport */
}

    </style>
</head>
<body>
    <canvas id="canvas1"></canvas>
    <script>
// // Get the canvas element from the HTML document
const canvas = document.getElementById('canvas1');

// Get the 2D rendering context of the canvas
const ctx = canvas.getContext('2d');

// Set the width and height of the canvas to match the window size
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

// Define the Particle class to represent individual particles
class Particle {
    constructor(effect, i) {
        // Reference to the Effect instance
        this.effect = effect;
        // Index of the particle
        this.index = i;
        // Radius of the particle
        this.radius = Math.floor(Math.random() * 25 + 2);
        // Initial position of the particle (random)
        this.x = this.radius + Math.random() * (this.effect.width - this.radius * 2);
        this.y = this.radius + Math.random() * (this.effect.height - this.radius * 2);
        // Velocity components of the particle
        this.vx = Math.random() * 1 - 0.5;
        this.vy = Math.random() * 1 - 0.5;
        // Forces applied to the particle
        this.pushX = 0;
        this.pushY = 0;
        // Friction coefficient
        this.friction = Math.random() * 0.4 + 0.2;
        // Color of the particle (random)
        this.color = 'hsl(' + (Math.random() * 150 + 200) + ', 100%, 50%)';
    }

    // Draw the particle on the canvas
    draw(context) {
        context.fillStyle = this.color;
        context.beginPath();
        context.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
        context.fill();

        context.fillStyle = 'white';
        context.beginPath();
        context.arc(this.x - this.radius * 0.3, this.y - this.radius * 0.2, this.radius * 0.5, 0, Math.PI * 2);
        context.fill();

        context.fillStyle = 'white';
        context.beginPath();
        context.arc(this.x + this.radius * 0.5, this.y - this.radius * 0.4, this.radius * 0.2, 0, Math.PI * 2);
        context.fill();
    }

    // Update the position of the particle
    update() {
        // Mouse interactions
        if (this.effect.mouse.pressed) {
            const dx = this.x - this.effect.mouse.x;
            const dy = this.y - this.effect.mouse.y;
            const distance = Math.hypot(dx, dy);
            const force = (this.effect.mouse.radius / distance);
            if (distance < this.effect.mouse.radius) {
                const angle = Math.atan2(dy, dx);
                this.pushX += Math.cos(angle) * force;
                this.pushY += Math.sin(angle) * force;
            }
        }

        // Collision with other particles
        this.effect.particles.forEach(particle => {
            if (particle.index != this.index) {
                const dx = this.x - particle.x;
                const dy = this.y - particle.y;
                const distance = Math.hypot(dy, dx);
                const sumOfRadii = particle.radius + this.radius;
                if (distance <= sumOfRadii) {
                    const unit_x = dx / distance;
                    const unit_y = dy / distance;
                    this.x = particle.x + (sumOfRadii + 0.1) * unit_x;
                    this.y = particle.y + (sumOfRadii + 0.1) * unit_y;
                }
            }
        });

        // Boundaries of the canvas
        if (this.x < this.radius) {
            this.x = this.radius;
            this.vx *= -1;
        } else if (this.x > this.effect.width - this.radius) {
            this.x = this.effect.width - this.radius;
            this.vx *= -1;
        }
        if (this.y < this.radius) {
            this.y = this.radius;
            this.vy *= -1;
        } else if (this.y > this.effect.height - this.radius) {
            this.y = this.effect.height - this.radius;
            this.vy *= -1;
        }

        // Update particle position
        this.x += (this.pushX *= this.friction) + this.vx;
        this.y += (this.pushY *= this.friction) + this.vy;
    }

    // Reset the position of the particle
    reset() {
        this.x = this.radius + Math.random() * (this.effect.width - this.radius * 2);
        this.y = this.radius + Math.random() * (this.effect.height - this.radius * 2);
    }
}

// Define the Effect class to manage the animation effect
class Effect {
    constructor(canvas, context) {
        // Reference to the canvas element
        this.canvas = canvas;
        // Reference to the canvas 2D context
        this.context = context;
        // Width of the canvas
        this.width = this.canvas.width;
        // Height of the canvas
        this.height = this.canvas.height;
        // Array to store particles
        this.particles = [];
        // Number of particles
        this.numberOfParticles = 100;
        // Create particles
        this.createParticles();

        // Mouse object to handle mouse interactions
        this.mouse = {
            x: 0, // Mouse x-coordinate
            y: 0, // Mouse y-coordinate
            pressed: false, // Mouse button pressed flag
            radius: 150 // Radius of mouse interaction
        }

        // Event listeners for window resize and mouse movement/interaction
        window.addEventListener('resize', e => {
            this.resize(e.target.window.innerWidth, e.target.window.innerHeight);
        });
        window.addEventListener('mousemove', e => {
            if (this.mouse.pressed) {
                this.mouse.x = e.x;
                this.mouse.y = e.y;
            }
        });
        window.addEventListener('mousedown', e => {
            this.mouse.pressed = true;
            this.mouse.x = e.x;
            this.mouse.y = e.y;
        });
        window.addEventListener('mouseup', e => {
            this
            // Set mouse pressed flag to false when mouse button is released
            this.mouse.pressed = false;
        });
    }

    // Create particles
    createParticles() {
        // Loop to create the specified number of particles
        for (let i = 0; i < this.numberOfParticles; i++) {
            // Create a new Particle instance and add it to the particles array
            this.particles.push(new Particle(this, i));
        }
    }

    // Handle particles - draw and update
    handleParticles(context) {
        // Connect particles with lines if they are within a certain distance
        this.connectParticles(context);
        // Loop through all particles to draw and update them
        this.particles.forEach(particle => {
            // Draw the particle on the canvas
            particle.draw(context);
            // Update the position of the particle
            particle.update();
        });
    }

    // Connect particles with lines if they are within a certain distance
    connectParticles(context) {
        // Maximum distance between particles to draw a line
        const maxDistance = 120;
        // Nested loops to compare each particle with every other particle
        for (let a = 0; a < this.particles.length; a++) {
            for (let b = a; b < this.particles.length; b++) {
                // Calculate the distance between particles
                const dx = this.particles[a].x - this.particles[b].x;
                const dy = this.particles[a].y - this.particles[b].y;
                const distance = Math.hypot(dx, dy);
                // Draw a line if the distance is within the maximum distance
                if (distance < maxDistance) {
                    context.save();
                    // Set line color based on the color of the first particle
                    context.strokeStyle = this.particles[a].color;
                    // Set line opacity based on the distance
                    const opacity = 1 - (distance / maxDistance);
                    context.globalAlpha = opacity;
                    // Draw the line between particles
                    context.beginPath();
                    context.moveTo(this.particles[a].x, this.particles[a].y);
                    context.lineTo(this.particles[b].x, this.particles[b].y);
                    context.stroke();
                    context.restore();
                }
            }
        }
    }

    // Resize the canvas and particles when the window is resized
    resize(width, height) {
        // Set new width and height for the canvas
        this.canvas.width = width;
        this.canvas.height = height;
        // Update the width and height properties
        this.width = width;
        this.height = height;
        // Reset the position of all particles
        this.particles.forEach(particle => {
            particle.reset();
        });
    }
}

// Create an instance of the Effect class to initialize the animation
const effect = new Effect(canvas, ctx);

// Function to continuously update and render the animation
function animate() {
    // Clear the canvas
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    // Update and draw particles
    effect.handleParticles(ctx);
    // Request the next animation frame
    requestAnimationFrame(animate);
}

// Start the animation
animate();

    </script>
</body>
</html>
